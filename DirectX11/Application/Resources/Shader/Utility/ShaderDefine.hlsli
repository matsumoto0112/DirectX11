
static const float EPSILON = 1e-6; //誤差

//ワールド・ビュー・プロジェクション行列
//2D時はviewに-(カメラの座標)の行列が入ってくる
struct MVPMatrix
{
    matrix world; //ワールド行列
    matrix view; //ビュー行列
    matrix proj; //プロジェクション行列
};

//平行光源
struct DirectionalLight
{
    float4 colDirLight; //色
    float3 dir; //方向
};

//点光源
struct PointLight
{
    float4 colPLight; //色
    float3 posPLight; //座標
    float R; //最大距離
    float A; //減衰率
};

//UV情報
struct UVInfo
{
    float left;
    float top;
    float width;
    float height;
};

//マテリアル情報
struct Material
{
    float4 ambient;
    float4 diffuse;
    float4 specular;
    float shininess;
    float alpha;
};

struct LightMatrix
{
    matrix view; //ライトビュー行列
    matrix proj; //ライト射影行列
};

//ワールド・ビュー・プロジェクション行列バッファ
cbuffer CB0 : register(b0)
{
    MVPMatrix mat;
}


//UV情報バッファ
cbuffer CB2 : register(b2)
{
    UVInfo uv;
}

//色情報バッファ
cbuffer CB3 : register(b3)
{
    float4 color = float4(1.0f, 1.0f, 1.0f, 1.0f);
}

//マテリアル
cbuffer CB5 : register(b4)
{
    Material material;
}

//カメラ数
cbuffer CameraNum : register(b5)
{
    int cameraNum;
}


cbuffer LightMat : register(b7)
{
    LightMatrix lightMat;
}

/**
* 法線ベクトルをワールド変換して正規化します
* @param nor4 4次元法線ベクトル
* @param world ワールド変換行列
* @return ワールド変換して正規化した法線ベクトル
*/
float3 getWorldNormal(float4 nor4, matrix world)
{
    return normalize(mul(nor4, world).xyz);
}

matrix createViewMatrix(float3 eye, float3 at, float3 up)
{
    const float3 zaxis = normalize(at - eye);
    const float3 xaxis = normalize(cross(up, zaxis));
    const float3 yaxis = cross(zaxis, xaxis);

    return float4x4(
        xaxis.x,                    yaxis.x,            zaxis.x,        0.0f,
        xaxis.y,                    yaxis.y,            zaxis.y,        0.0f,
        zaxis.z,                    yaxis.z,            zaxis.z,        0.0f,
        -dot(xaxis, eye),   -dot(yaxis, eye),   -dot(zaxis, eye),       1.0f
    );

}

matrix MVP()
{
    matrix res = mul(mat.world, mat.view);
    res = mul(res, mat.proj);
    return res;
}